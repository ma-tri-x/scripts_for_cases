#!/bin/bash
pi="3.14159265358979323846264338327950288"

source $HOME/foam/foam-extend-4.0/etc/bashrc

if [ true = "true" ];then
bash Allclean
fi

if [[ true = "true" ]]; then
 parallel=true
fi

if [ $parallel ];then  bash decompose.sh 8 2 1 metis; fi

. $WM_PROJECT_DIR/bin/tools/RunFunctions
application=`getApplication`


runRefineMesh ()
{
    #echo "Running refineMesh on $PWD"
    refineMesh -dict > log.refineMesh 
}

copy_0backup ()
{
 echo -e "\ncopying 0/backup/ files..."
 cp 0/backup/alpha1.org 0/alpha1
 cp 0/backup/p.org 0/p_rgh
 cp 0/backup/rho_gTilde.org 0/rho_gTilde
#  cp 0/backup/rho_gTilde.org 0/rho2Tilde
#  cp 0/backup/rho_gSource.org 0/rho_gSource
 cp 0/backup/U 0/U
 cp 0/backup/passiveScalar 0/passiveScalar
}

### get solver commit version number: #####
thisdir=$(pwd)
if [[ $application == "localMassCorr_working" || $application == "localMassCorr_working_opt" ]]
then
    cd $WM_PROJECT_DIR/applications/solvers/multiphase/localMassCorr_working
    version_number=$(git log | head -n 1 | sed "s/commit //g")
    cd $thisdir
    echo $version_number > solver_version_number.info
fi
###########################################

meshFile=constant/polyMesh/blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4

if [ "false" = "true" ]
then
    echo "overwriting adaptive theta in mesh with 2.0 degrees"
    sed -i "s#//_ALLRUN-OVERWRITETHETA#define(theta, calc(2.0 /PI*180.))#g" $meshFile
fi

echo "m4ing ..."
m4 constant/polyMesh/blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4 > constant/polyMesh/blockMeshDict

copy_0backup
 
if [ "true" = "true" ];then
echo "blockMeshing..."
blockMesh > log.blockMesh
else
echo "NOT blockMeshing"
fi

if [ "true" = "true" ] ; then
    echo "stitching mesh by using stitchMesh.sh..."
    rm -f 0/cellDist
    bash stitchMesh.sh
fi

if [ "false" = "true" ]
then
    echo "prepare refining mesh..."
    rm system/cellSetDict.?
    rm system/cellSetDict.??
    #n0=_MESH-STARTCELLAMOUNT
    #csgoal=3e-06GOAL
    #size=_MESH-SIZE
    if [ false = "true" ]
    then
        iterations=6 #$(m4 <<< "esyscmd(perl -e 'use Math::Round; printf (  round(log($size/($n0**(1./3.))/$csgoal)/log(2.)) )')")
        iterations=`expr $iterations + 1`
        if [ $iterations -gt 13 ]
        then
            echo "impossible number of iterations: $iterations > 10"
            exit 1
        fi
        refineUntil=0.003
        refineFrom=8e-05
        j=1
        while [ $j -lt $iterations ] ; do
            echo "cp system cellSetDict.1.backup system/cellSetDict.$j"
            cp system/cellSetDict.1.backup system/cellSetDict.$j
            dinit=0.000792
            if [ $(python check_str_in_str.py "axisymm_radial" "blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4") ]
            then
                dinit=0.0
            fi
            sed -i "s/dinit/${dinit}/g" system/cellSetDict.$j
            refDist=$(m4 <<< "esyscmd(perl -e 'printf (  (${refineUntil} - ${refineFrom} )*(($j - $iterations )/( $iterations -1.))**2 +$refineFrom )')")
            sed -i "s/rrradius/$refDist/g" system/cellSetDict.$j
    #         refDist=$(m4 <<< "esyscmd(perl -e 'printf ( $refDist - $distOfRefineStep  )')")
            j=`expr $j + 1`
        done
    else
        refDistsInRmax="60 15 9 6 3 2 1 0.8 0.5 0.2"
        j=1
        for refDistRmax in $refDistsInRmax;do
            echo "cp system cellSetDict.1.backup system/cellSetDict.$j"
            cp system/cellSetDict.1.backup system/cellSetDict.$j
            dinit=0.000792
            if [ $(python check_str_in_str.py "axisymm_radial" "blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4") ]
            then
                dinit=0.0
            fi
            sed -i "s/dinit/${dinit}/g" system/cellSetDict.$j
            refDist=$(m4 <<< "esyscmd(perl -e 'printf (  $refDistRmax * 0.000495 )')")
            sed -i "s/rrradius/$refDist/g" system/cellSetDict.$j
            if [[ $j == 8 ]];then
                sed -i "s#//  boxToCell#boxToCell#g" system/cellSetDict.$j
            fi
            j=`expr $j + 1`
        done
    fi
    j=1
    while [ -e system/cellSetDict.$j ] ; do
        echo "refining step $j..."
        cp system/cellSetDict.$j system/cellSetDict
        cellSet > log.cellSet
        mv log.cellSet log.cellSet.$j
        echo "refining mesh..."
        runRefineMesh # eigene Funktion! Siehe oben
        mv log.refineMesh log.refineMesh.$j
        cp -r $(python find_biggestNumber.py -p .)/polyMesh/* constant/polyMesh
        rm -rf $(python find_biggestNumber.py -p .)
        j=`expr $j + 1`
    done
fi

if [ "false" = "true" ]
then
    echo "making axial mesh with angle 4 degrees and patch names frontandback"
    makeAxialMesh -wedge frontandback -wedgeAngle 4 -axis axis > log.makeAxialMesh
    echo "collapsingEdges ..."
    collapseEdges 1e-8 180 -overwrite > log.collapseEdges
    if [ -d 0/polyMesh ]
    then
        cp 0/polyMesh/* constant/polyMesh/ # <-important bec otherwise decomposePar wont write processor*/0 folders
        sed -i "s/symmetryPlane/empty/g" 0/polyMesh/boundary
        rm -rf 0/polyMesh # <-important bec otherwise decomposePar wont write processor*/0 folders
    fi
    checkMesh > log.checkMesh
    sed -i "s/symmetryPlane/empty/g" constant/polyMesh/boundary
    echo $(grep -E "Zero|zero|skew|Skew" log.checkMesh)
#     exit 0
fi

if [ "true" = "true" ]
then
    echo "preparing snappy..."
    rm -f 0/*.gz
    rm -rf 0/uniform
    copy_0backup
    echo "snappyHexMeshing ..."
    snappyHexMesh -overwrite > log.snappyHexMesh
    #cp -r $(python find_biggestNumber.py -p .)/polyMesh/* constant/polyMesh
    #ts=$(python find_biggestNumber.py -p .)
    #while [[ $ts != 0.0 && $ts != "0.0" ]] ;do
    #    echo "rm -rf $ts"
    #    rm -rf $ts
    #    ts=$(python find_biggestNumber.py -p .)
    #done
    copy_0backup
fi

# exit 0
    
pVar="p_rgh"

echo -e "\nsetting fields..."

gamma=1.4
Rn=0.0001841
pV=0.0
pStat=101315
sigma=0.0725
#BVAN=0.0000364 # m^3/mol
muwater=0.001002
TEMPREF=293.15
GASCONSTGENERAL=8.3144621 # J/mol K
SPECGASCONST=287.0
beta=0.0

pn=$(m4 <<< "esyscmd(perl -e 'printf (${pStat} + 2.*${sigma}/${Rn} -${pV}  )')")
RMax=0.000495
R=2e-05
width=2e-08 # width of interface
Uif=0.0

if [ "false" = 'true' ];then
    echo "Converting volume to a grid fitting box volume..."
    cellsize=3e-06
    sphereVol=$(m4 <<< "esyscmd(perl -e 'printf (   4.*${pi}/3.*(${R})**3  )')")
    if [ ""2D"" = "3D" ];then
        boxEdgeLength_theory=$(m4 <<< "esyscmd(perl -e 'printf (   (${sphereVol})**(1./3.)  )')")
        number_of_fitting_cells=$(m4 <<< "esyscmd(perl -e 'printf (   int(${boxEdgeLength_theory}/${cellsize})  )')")
        boxEdgeLength_true=$(m4 <<< "esyscmd(perl -e 'printf (   ${number_of_fitting_cells}*${cellsize}  )')")
        boxVol=$(m4 <<< "esyscmd(perl -e 'printf (   ${boxEdgeLength_true}**3  )')")
        R=$(m4 <<< "esyscmd(perl -e 'printf (   (${boxVol}/(4.*${pi})*3)**(1./3.)  )')")
        echo "volume change from theoretical sphere to box: $(m4 <<< "esyscmd(perl -e 'printf (   ${boxVol}/${sphereVol}  )')")"
    elif [ ""2D"" = "2D" ];then
        #box is now cylinder: boxEdgeLength_theory=radius
        height=$(m4 <<< "esyscmd(perl -e 'printf (   int(2*${R}/${cellsize})*$cellsize  )')")
        boxEdgeLength_theory=$(m4 <<< "esyscmd(perl -e 'printf (   sqrt(${sphereVol}/${height}/${pi})  )')")
        number_of_fitting_cells=$(m4 <<< "esyscmd(perl -e 'printf (   int(${boxEdgeLength_theory}/${cellsize})  )')")
        boxEdgeLength_true=$(m4 <<< "esyscmd(perl -e 'printf (   ${number_of_fitting_cells}*${cellsize}  )')")
        boxVol=$(m4 <<< "esyscmd(perl -e 'printf (   ${pi}*${boxEdgeLength_true}**2 * ${height} )')")
        R=$(m4 <<< "esyscmd(perl -e 'printf (   (${boxVol}/(4.*${pi})*3)**(1./3.)  )')")
        echo "volume change from theoretical sphere to box: $(m4 <<< "esyscmd(perl -e 'printf (   ${boxVol}/${sphereVol}  )')")"
    else
        echo "boxBubble not yet implemented for meshdims other than 2D and 3D"
        exit 1
    fi
fi


pAtMax=$(m4 <<< "esyscmd(perl -e 'printf (   ${pn}*((${Rn}**3. - ${beta}*${Rn}**3.)/(${RMax}**3. - ${beta}*${Rn}**3.))**${gamma}  )')")
rho_n=$(m4 <<< "esyscmd(perl -e 'printf ( $pn/($SPECGASCONST*$TEMPREF*(1.-$beta))  )')")
rho_min=$(m4 <<< "esyscmd(perl -e 'printf ( $rho_n * ($Rn/$RMax)**3. )')")
Z=$(m4 <<< "esyscmd(perl -e 'printf (   (${RMax}/${R})**(3.)  )')")
Q=$(m4 <<< "esyscmd(perl -e 'printf (   ${pn}*((${Rn}**3. - ${beta}*${Rn}**3.)/(${RMax}**3. - ${beta}*${Rn}**3.))**${gamma}  )')")
# current pressure of Bubble (if you do not start at RMax)
pBubble=$(m4 <<< "esyscmd(perl -e 'printf (   ${pn}*((${Rn}**3. - ${beta}*${Rn}**3.)/(${R}**3. - ${beta}*${Rn}**3.))**${gamma}  )')") #1e9 #$Q
Pm=$(m4 <<< "esyscmd(perl -e 'printf ( ${pStat} + 2.*${sigma}/${R} + 4.*${muwater}*${Uif}/${R} -${pV})' )")



nCells=$(grep "nCells" log.blockMesh)

echo "p_n              = $pn      "
echo "beta             = $beta    "
echo "RMax             = $RMax    "
echo "R                = $R       "
echo "widthOfInterface = $width   "
echo "Uif              = $Uif     "
echo "pAtRMax          = $pAtMax  "
echo "rho_n            = $rho_n   "
echo "rho_min          = $rho_min "
echo "Z                = $Z       "
echo "Q                = $Q       "
echo "pBubble          = $pBubble "
echo "Pm               = $Pm      "
echo $nCells
echo "cells now: $(checkMesh | grep "cells:" | sed "s/\s//g" | sed "s/cells://g")"

time=0.0

if [ "false" = "false" ]
then
    echo "" > log.setFields
    offset=0.000792
    if [ "blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4" = "blockMeshDict_axisymm_ChCore.m4" ]
    then
        offset=$(m4 <<< "esyscmd(perl -e 'printf ( $R + 1e-6 )')")
    fi 
    if [ $(python check_str_in_str.py "blockMeshDict_axisymm_coreCart_reg_unbound" "blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4") ]
    then
        offset=0.0
    fi 
    if [ $(python check_str_in_str.py "axisymm_radial" "blockMeshDict_axisymm_coreCart_reg_unbound_writeTheta_V2.m4") ]
    then
        offset=0.0
    fi
    dist=$offset

    unit_vector="vector(pos().x,pos().y-$dist,pos().z)/\
                (sqrt(pos().x*pos().x +\
                    (pos().y-${dist})*(pos().y-${dist}) +\
                        pos().z*pos().z))"
    distance_vector="vector(pos().x,pos().y-$dist,pos().z)"
    radial_distance="sqrt(pos().x*pos().x + \
                    (pos().y-${dist})*(pos().y-${dist}) + pos().z*pos().z)"

    if [ "_FUNKYSETFIELDS-CYLINDERPLASMA" = "true" ]
    then
        cyl_h=_BUBBLE-PLASMAHEIGHT
        cyl_rad=$(m4 <<< "esyscmd(perl -e 'printf ( sqrt(4.*${R}**3/(3.*${cyl_h})) )')")
        funkySetFields -case . -field alpha1 -expression "1"\
                        -time $time -keepPatches >> log.setFields  #-condition 'pos().x <= 50e-6' 
        funkySetFields -case . -field alpha1 -expression "0"\
                        -time $time -keepPatches -condition "pos().x <= ${cyl_rad} && pos().y <= ${cyl_h}/2. + $offset && pos().y >= $offset - ${cyl_h}/2."  >> log.setFields  #
    else
        funkySetFields -case . -field alpha1 -expression "0.5*(tanh(($radial_distance-${R})*5.9/${width})+1)"\
                        -time $time -keepPatches >> log.setFields  #-condition 'pos().x <= 50e-6' 
    fi

    if [ "false" = "true" ];then
        if [ ""2D"" = "3D" ];then
            blhalf=$(m4 <<< "esyscmd(perl -e 'printf ( $boxEdgeLength_true / 2. )')") 
            funkySetFields -case . -field alpha1 -expression "1.0" -time $time -keepPatches >> log.setFields
            funkySetFields -case . -field alpha1 -expression "0.0" -time $time -keepPatches \
            -condition "pos().x <= $blhalf && pos().x >= -$blhalf && \
            pos().y <= $blhalf +$dist && pos().y >= -$blhalf+$dist && \
            pos().z <= $blhalf && pos().z >= -$blhalf " >> log.setFields  #-condition 'pos().x <= 50e-6' 
        elif [ ""2D"" = "2D" ];then
            hgthalf=$(m4 <<< "esyscmd(perl -e 'printf ( $height / 2. )')") 
            bl=$boxEdgeLength_true
            funkySetFields -case . -field alpha1 -expression "1.0" -time $time -keepPatches >> log.setFields
            funkySetFields -case . -field alpha1 -expression "0.0" -time $time -keepPatches \
            -condition "pos().x <= $bl  && \
            pos().y <= $hgthalf+$dist && pos().y >= -$hgthalf+$dist " >> log.setFields  #-condition 'pos().x <= 50e-6' 
        fi
    else
        funkySetFields -case . -field alpha1 -expression "0.5*(tanh(($radial_distance-${R})*5.9/${width})+1)"\
                        -time $time -keepPatches >> log.setFields  #-condition 'pos().x <= 50e-6' 
    fi
    funkySetFields -case . -field U      -expression "0.*vector(0,1,0)" -keepPatches -time $time >> log.setFields 


    if [ "hom" = "developed" ]
    then
        echo "---- using historically developed pressure profile ----"
    #        (1.-alpha1)*${pBubble} + alpha1*
        funkySetFields -case . -field $pVar  -expression "
        (
        ${R}/(-3.*$radial_distance)
        * (  (${Q}*pow(${Z},${gamma})*(3.*${gamma}-4) + ${Q}*${Z})/(1-${gamma}) - (${Z}-4)*${Pm} )   
        + ${pStat} 
        - pow(${R},4) / (3.*pow($radial_distance,4)) * 
        ( ${Pm}*(${Z}-1)-${Q}*(${Z} -pow(${Z},${gamma}))/(1-${gamma}) )
        )"  -time $time -keepPatches -condition "$radial_distance >= ${R}" >> log.setFields

        funkySetFields -case . -field $pVar  -expression "${pBubble}" -time $time -keepPatches -condition "
        $radial_distance < ${R}" >> log.setFields
        funkySetFields -case . -field $pVar  -expression "2.5" -time $time -keepPatches \
                    -condition "${pVar} < 2.5" >> log.setFields
    else
        echo "---- using theta jump pressure profile ----"
        get_alpha2_vol_t0 > log.get_alpha2_vol_t0
        true_alpha2_vol=$(cat 0/alpha2_vol_t0)
        if [ ""2D"" = "2D" ];then
            if [ ! -e THETA ];then
                echo "ERROR: alter your meshDict.m4 such that it writes theta into THETA"
                exit 1
            fi
            theta=$(cat THETA)
            true_alpha2_vol=$(m4 <<< "esyscmd(perl -e 'printf (  $true_alpha2_vol *180./${theta}  )')")
        elif [ ""2D"" = "1D" ];then
            if [ ! -e THETA ];then
                echo "ERROR: alter your meshDict.m4 such that it writes theta into THETA"
                exit 1
            fi
            theta=$(cat THETA)
            theta_rad=$(m4 <<< "esyscmd(perl -e 'printf (  ${theta}*${pi}/180.  )')")
            true_alpha2_vol=$(m4 <<< "esyscmd(perl -e 'use Math::Trig; printf (  ${true_alpha2_vol}*${pi}/(tan(${theta_rad}))**2  )')")
        fi
        Vn=$(m4 <<< "esyscmd(perl -e 'printf (   4.*${pi}/3.* ${Rn}**(3.)  )')")
        V0=$(m4 <<< "esyscmd(perl -e 'printf (   4.*${pi}/3.* ${R}**(3.)  )')")
        R=$(m4 <<< "esyscmd(perl -e 'printf (   (${true_alpha2_vol}/(4.*${pi})*3)**(1./3.)  )')")
        Ebubble=$(m4 <<< "esyscmd(perl -e 'printf (   ($pBubble * $V0 - $pn * $Vn )/($gamma -1.)  )')")
        pBubble=$(m4 <<< "esyscmd(perl -e 'printf (   ($Ebubble * ($gamma -1.) + $pn *$Vn )/$true_alpha2_vol  )')")
        echo "python get_true_Rn_from_R0_p0_Rn_sigma.py --R0 $R -s $sigma --p0 $pBubble"
        Rn=$(python get_true_Rn_from_R0_p0_Rn_sigma.py --R0 $R -s $sigma --p0 $pBubble --pinf $pStat )
        echo $Rn > Rn_export
        pn=$(m4 <<< "esyscmd(perl -e 'printf (${pStat} + 2.*${sigma}/${Rn} -${pV}  )')")
        echo "R_0new           = $R "
        echo "R_n_new          = $Rn "
        echo "pBubble          = $pBubble "
        funkySetFields -case . -field $pVar -expression "${pBubble}*(1.-alpha1)+${pStat}*alpha1"\
                    -time $time -keepPatches >> log.setFields
    fi

    ##############################################
    dist=$offset
    if [ "zero" = "mirrorbubble" ]
    then
        echo "---- using Christianes U profile ----"
        funkySetFields -case . -field U -expression "2.*${Uif}*${R}*${R}*$distance_vector/pow(pow(pos().x,2) + pow(pos().y-${dist},2) + pow(pos().z,2),1.5)" -condition "$radial_distance >= ${R}" -keepPatches -time $time >> log.setFields

        funkySetFields -case . -field U -expression "${Uif}*( $distance_vector/(${R}) +         ${R}*${R}*$distance_vector/pow(pow(pos().x,2) + pow(pos().y+${dist},2) + pow(pos().z,2),1.5) )"             -condition "$radial_distance < ${R}"              -keepPatches -time $time >> log.setFields

        #funkySetFields -case . -field ${pVar} -expression\
        #"${pBubble}*(1.-alpha1)+alpha1*${pStat}" -time $time -keepPatches >> log.setFields
    elif [ "zero" = "wicked" ]
    then
        echo "---- using wicked U profile with decay 0.00012 ----"

        funkySetFields -case . -field U -expression \
            "${Uif}*$unit_vector*exp(-($radial_distance - $R)*2./0.00012)"\
            -condition "$radial_distance >= ${R}" \
            -keepPatches -time $time >> log.setFields

        funkySetFields -case . -field U -expression \
            "${Uif}/${R}*$distance_vector"\
                -condition "$radial_distance < ${R}" \
                -keepPatches -time $time >> log.setFields
    elif [ "zero" = "inletoutlet" ]
    then
        echo "---- using inletoutlet U profile ----"
        funkySetFields -case . -field U -expression "1.0*vector(0,1,0)" -keepPatches -time $time >> log.setFields
    else
        echo "---- using simple U profile where U > 0 ----"

        funkySetFields -case . -field U -expression \
            "${Uif}*$unit_vector*$R/\
            pow($radial_distance,1.0)"\
            -condition "$radial_distance >= ${R}" \
            -keepPatches -time $time >> log.setFields

        funkySetFields -case . -field U -expression \
            "${Uif}/${R}*$distance_vector"\
                -condition "$radial_distance < ${R}" \
                -keepPatches -time $time >> log.setFields
    fi
    if [ -e 0/amrAllow ]
    then
            amrDisallowDown=_MESH-AMRDISALLOWDOWN
            amrDisallowUp=_MESH-AMRDISALLOWUP
            amrDisallowRight=_MESH-AMRDISALLOWRIGHT
            funkySetFields -case . -field amrAllow -expression "1" -time 0 -keepPatches  \
                                >> sc_log.setFields
            funkySetFields -case . -field amrAllow -expression "0" -time 0 -keepPatches  \
                    -condition "pos().y < $amrDisallowUp && pos().y > $amrDisallowDown \
                                && pos().x < $amrDisallowRight " >> sc_log.setFields
    fi
    if [[ "metis" == "manual" ]]
    then
        python _DECOMPOSE-MANUALSCRIPT
        #cp constant/cellDist 0/
        #sed -i "s/constant/0/g" 0/cellDist
    fi
    #-----------------passiveScalar part: -------------------
    #X=$(m4 <<< "esyscmd(perl -e 'printf ( 2.*${RMax} )' )")
    #Y=$(m4 <<< "esyscmd(perl -e 'printf ( 1.5 *(${RMax} + 0.000792 ) )' )")
    Y=$(m4 <<< "esyscmd(perl -e 'printf ( 1.5 *(${RMax}  ) )' )")
    echo "---- passiveScalar part till X,Y: $X,$Y ----"

    funkySetFields -case . -field passiveScalar -expression "1.0" -time 0 -keepPatches  >> log.setFields
    funkySetFields -case . -field passiveScalar -expression "pos().y/$Y" -time 0 -keepPatches  \
                    -condition "pos().y < $Y " >> log.setFields
    #---------------------------------------------------------
    ###############################################
    ###############################################

else
    startTime=0.0
    sourceDir=../0045_91_lbPaper_RC_1.35
    thisdir=$(pwd)
    cd $sourceDir
    reconstructPar -time $startTime > log.reconstructPar
    cd $thisdir
    if [ ! -d $startTime ]
    then 
        mkdir $startTime
        cp 0/* $startTime
    fi
    echo "---- mapping fields with $sourceDir  ........"
    mapFields $sourceDir  > log.mapFields
fi


if [ $parallel ];then
    echo "decomposing with xyz: 8 2 1 by method: metis"
    decomposePar > log.decomposePar


    if [ ! -d processor0/constant/polyMesh ]
    then
        echo "writing mesh to processor*/constant because it wasn't created..."
        for coreDir in processor*; do 
            mkdir -p $coreDir/constant
            mv $coreDir/0/polyMesh $coreDir/constant
            rm -rf $coreDir/0
        done
    fi


    slots=$(grep "^numberOfSubdomains" system/decomposeParDict | sed "s/^numberOfSubdomains *\([0-9]*\);/\1/")
    method=$( grep "^method" system/decomposeParDict | sed "s/^method *\([a-zA-Z]*\);/\1/")
    echo "slots = ${slots}, decomposed with $method"
    if [ -e constant/dynamicMeshDict ]
    then
        for i in proc*
        do
            cp constant/dynamicMeshDict $i/constant/
        done
    fi
    
    if [ "true" == "true" ]
    then
        mkdir -p constant/polyMesh/temp
        mv constant/polyMesh/*.gz      constant/polyMesh/temp
        mv constant/polyMesh/boundary  constant/polyMesh/temp
    fi
fi

    
if [ "false" == "true" ];then
a=$(date)
    if [ "true" = "true" ];then
        rm constant/polyMesh/*.gz #important for dynamicRefine2DMesh to work.
        echo "-- running in parallel --"
	echo "output of which command: $(which localMassCorr_working_7894e6f)"
        echo "mpirun -np $slots localMassCorr_working_7894e6f -parallel > run.log #> /dev/null 2>&1 #> run.log"
    mpirun -np $slots localMassCorr_working_7894e6f -parallel 2>&1 > run.log  #> /dev/null 2>&1 #> run.log
    else
        echo "-- running on single core --"
        localMassCorr_working_7894e6f > run.log #/dev/null 2>&1 #> run.log
    fi
    python copy_solver_here.py
b=$(date)
echo "automatic case running took from $a to $b"
fi

 massFile=postProcessing/volumeIntegrate_volumeIntegral/0/rhoBubble
 if [ -e $massFile ];then 
    cp $massFile ${massFile}ForParaView
    sed -i "s/#//g" ${massFile}ForParaView
 fi

# ----------------------------------------------------------------- end-of-file
